// This code was AUTOGENERATED using Codama IDLs.
// Please DO NOT EDIT THIS FILE manually.
// Instead, update the IDL and regenerate using:
// ./gradlew :codegen:generateSolanaCode
//
// IDL source: codegen/idl/token-2022.json

package net.avianlabs.solana.domain.program

import kotlin.Boolean
import kotlin.Byte
import kotlin.ByteArray
import kotlin.Double
import kotlin.Long
import kotlin.Short
import kotlin.String
import kotlin.UByte
import kotlin.ULong
import kotlin.UShort
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.jvm.JvmInline
import net.avianlabs.solana.domain.core.AccountMeta
import net.avianlabs.solana.domain.core.TransactionInstruction
import net.avianlabs.solana.domain.program.Program.Companion.createTransactionInstruction
import net.avianlabs.solana.tweetnacl.ed25519.PublicKey
import okio.Buffer

public object Token2022Program : Program {
  public override val programId: PublicKey =
      PublicKey.fromBase58("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")

  public val RENT: PublicKey = PublicKey.fromBase58("SysvarRent111111111111111111111111111111111")

  public val INSTRUCTIONS_SYSVAR_OR_CONTEXT_STATE: PublicKey =
      PublicKey.fromBase58("Sysvar1nstructions1111111111111111111111111")

  public val MULTISIG_LENGTH: Long = 355L

  /**
   * Initializes a new mint and optionally deposits all the newly minted
   * tokens in an account.
   *
   * The `InitializeMint` instruction requires no signers and MUST be
   * included within the same Transaction as the system program's
   * `CreateAccount` instruction that creates the account being initialized.
   * Otherwise another party can acquire ownership of the uninitialized account.
   */
  public fun initializeMint(
    mint: PublicKey,
    decimals: UByte,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey?,
    rent: PublicKey = RENT,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(rent, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeMint.index.toInt())
      .writeByte(decimals.toInt())
      .write(mintAuthority.bytes)
      .apply {
        if (freezeAuthority != null) {
          writeByte(1)
          .write(freezeAuthority.bytes)
        } else {
          writeByte(0)
        }
      }
      .readByteArray(),
  )

  /**
   * Initializes a new account to hold tokens. If this account is associated
   * with the native mint then the token balance of the initialized account
   * will be equal to the amount of SOL in the account. If this account is
   * associated with another mint, that mint must be initialized before this
   * command can succeed.
   *
   * The `InitializeAccount` instruction requires no signers and MUST be
   * included within the same Transaction as the system program's
   * `CreateAccount` instruction that creates the account being initialized.
   * Otherwise another party can acquire ownership of the uninitialized account.
   */
  public fun initializeAccount(
    account: PublicKey,
    mint: PublicKey,
    owner: PublicKey,
    rent: PublicKey = RENT,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(owner, isSigner = false, isWritable = false),
      AccountMeta(rent, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeAccount.index.toInt())
      .readByteArray(),
  )

  /**
   * Initializes a multisignature account with N provided signers.
   *
   * Multisignature accounts can used in place of any single owner/delegate
   * accounts in any token instruction that require an owner/delegate to be
   * present. The variant field represents the number of signers (M)
   * required to validate this multisignature account.
   *
   * The `InitializeMultisig` instruction requires no signers and MUST be
   * included within the same Transaction as the system program's
   * `CreateAccount` instruction that creates the account being initialized.
   * Otherwise another party can acquire ownership of the uninitialized account.
   */
  public fun initializeMultisig(
    multisig: PublicKey,
    m: UByte,
    rent: PublicKey = RENT,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(multisig, isSigner = false, isWritable = true),
      AccountMeta(rent, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeMultisig.index.toInt())
      .writeByte(m.toInt())
      .readByteArray(),
  )

  /**
   * Transfers tokens from one account to another either directly or via a delegate.
   * If this account is associated with the native mint then equal amounts
   * of SOL and Tokens will be transferred to the destination account.
   */
  public fun transfer(
    source: PublicKey,
    destination: PublicKey,
    authority: PublicKey,
    amount: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(source, isSigner = false, isWritable = true),
      AccountMeta(destination, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.Transfer.index.toInt())
      .writeLongLe(amount.toLong())
      .readByteArray(),
  )

  /**
   * Approves a delegate. A delegate is given the authority over tokens on
   * behalf of the source account's owner.
   */
  public fun approve(
    source: PublicKey,
    `delegate`: PublicKey,
    owner: PublicKey,
    amount: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(source, isSigner = false, isWritable = true),
      AccountMeta(delegate, isSigner = false, isWritable = false),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.Approve.index.toInt())
      .writeLongLe(amount.toLong())
      .readByteArray(),
  )

  /**
   * Revokes the delegate's authority.
   */
  public fun revoke(source: PublicKey, owner: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(source, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.Revoke.index.toInt())
      .readByteArray(),
  )

  /**
   * Sets a new authority of a mint or account.
   */
  public fun setAuthority(
    owned: PublicKey,
    owner: PublicKey,
    authorityType: AuthorityType,
    newAuthority: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(owned, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.SetAuthority.index.toInt())
      .writeByte(authorityType.value.toInt())
      .apply {
        if (newAuthority != null) {
          writeByte(1)
          .write(newAuthority.bytes)
        } else {
          writeByte(0)
        }
      }
      .readByteArray(),
  )

  /**
   * Mints new tokens to an account. The native mint does not support minting.
   */
  public fun mintTo(
    mint: PublicKey,
    token: PublicKey,
    mintAuthority: PublicKey,
    amount: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(mintAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.MintTo.index.toInt())
      .writeLongLe(amount.toLong())
      .readByteArray(),
  )

  /**
   * Burns tokens by removing them from an account. `Burn` does not support
   * accounts associated with the native mint, use `CloseAccount` instead.
   */
  public fun burn(
    account: PublicKey,
    mint: PublicKey,
    authority: PublicKey,
    amount: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.Burn.index.toInt())
      .writeLongLe(amount.toLong())
      .readByteArray(),
  )

  /**
   * Close an account by transferring all its SOL to the destination account.
   * Non-native accounts may only be closed if its token amount is zero.
   */
  public fun closeAccount(
    account: PublicKey,
    destination: PublicKey,
    owner: PublicKey,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
      AccountMeta(destination, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.CloseAccount.index.toInt())
      .readByteArray(),
  )

  /**
   * Freeze an Initialized account using the Mint's freeze_authority (if set).
   */
  public fun freezeAccount(
    account: PublicKey,
    mint: PublicKey,
    owner: PublicKey,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.FreezeAccount.index.toInt())
      .readByteArray(),
  )

  /**
   * Thaw a Frozen account using the Mint's freeze_authority (if set).
   */
  public fun thawAccount(
    account: PublicKey,
    mint: PublicKey,
    owner: PublicKey,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ThawAccount.index.toInt())
      .readByteArray(),
  )

  /**
   * Transfers tokens from one account to another either directly or via a
   * delegate. If this account is associated with the native mint then equal
   * amounts of SOL and Tokens will be transferred to the destination account.
   *
   * This instruction differs from Transfer in that the token mint and
   * decimals value is checked by the caller. This may be useful when
   * creating transactions offline or within a hardware wallet.
   */
  public fun transferChecked(
    source: PublicKey,
    mint: PublicKey,
    destination: PublicKey,
    authority: PublicKey,
    amount: ULong,
    decimals: UByte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(source, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(destination, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.TransferChecked.index.toInt())
      .writeLongLe(amount.toLong())
      .writeByte(decimals.toInt())
      .readByteArray(),
  )

  /**
   * Approves a delegate. A delegate is given the authority over tokens on
   * behalf of the source account's owner.
   *
   * This instruction differs from Approve in that the token mint and
   * decimals value is checked by the caller. This may be useful when
   * creating transactions offline or within a hardware wallet.
   */
  public fun approveChecked(
    source: PublicKey,
    mint: PublicKey,
    `delegate`: PublicKey,
    owner: PublicKey,
    amount: ULong,
    decimals: UByte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(source, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(delegate, isSigner = false, isWritable = false),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ApproveChecked.index.toInt())
      .writeLongLe(amount.toLong())
      .writeByte(decimals.toInt())
      .readByteArray(),
  )

  /**
   * Mints new tokens to an account. The native mint does not support minting.
   *
   * This instruction differs from MintTo in that the decimals value is
   * checked by the caller. This may be useful when creating transactions
   * offline or within a hardware wallet.
   */
  public fun mintToChecked(
    mint: PublicKey,
    token: PublicKey,
    mintAuthority: PublicKey,
    amount: ULong,
    decimals: UByte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(mintAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.MintToChecked.index.toInt())
      .writeLongLe(amount.toLong())
      .writeByte(decimals.toInt())
      .readByteArray(),
  )

  /**
   * Burns tokens by removing them from an account. `BurnChecked` does not
   * support accounts associated with the native mint, use `CloseAccount` instead.
   *
   * This instruction differs from Burn in that the decimals value is checked
   * by the caller. This may be useful when creating transactions offline or
   * within a hardware wallet.
   */
  public fun burnChecked(
    account: PublicKey,
    mint: PublicKey,
    authority: PublicKey,
    amount: ULong,
    decimals: UByte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.BurnChecked.index.toInt())
      .writeLongLe(amount.toLong())
      .writeByte(decimals.toInt())
      .readByteArray(),
  )

  /**
   * Like InitializeAccount, but the owner pubkey is passed via instruction
   * data rather than the accounts list. This variant may be preferable
   * when using Cross Program Invocation from an instruction that does
   * not need the owner's `AccountInfo` otherwise.
   */
  public fun initializeAccount2(
    account: PublicKey,
    mint: PublicKey,
    owner: PublicKey,
    rent: PublicKey = RENT,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(rent, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeAccount2.index.toInt())
      .write(owner.bytes)
      .readByteArray(),
  )

  /**
   * Given a wrapped / native token account (a token account containing SOL)
   * updates its amount field based on the account's underlying `lamports`.
   * This is useful if a non-wrapped SOL account uses
   * `system_instruction::transfer` to move lamports to a wrapped token
   * account, and needs to have its token `amount` field updated.
   */
  public fun syncNative(account: PublicKey): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.SyncNative.index.toInt())
      .readByteArray(),
  )

  /**
   * Like InitializeAccount2, but does not require the Rent sysvar to be provided.
   */
  public fun initializeAccount3(
    account: PublicKey,
    mint: PublicKey,
    owner: PublicKey,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeAccount3.index.toInt())
      .write(owner.bytes)
      .readByteArray(),
  )

  /**
   * Like InitializeMultisig, but does not require the Rent sysvar to be provided.
   */
  public fun initializeMultisig2(multisig: PublicKey, m: UByte): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(multisig, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeMultisig2.index.toInt())
      .writeByte(m.toInt())
      .readByteArray(),
  )

  /**
   * Like [`InitializeMint`], but does not require the Rent sysvar to be provided.
   */
  public fun initializeMint2(
    mint: PublicKey,
    decimals: UByte,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeMint2.index.toInt())
      .writeByte(decimals.toInt())
      .write(mintAuthority.bytes)
      .apply {
        if (freezeAuthority != null) {
          writeByte(1)
          .write(freezeAuthority.bytes)
        } else {
          writeByte(0)
        }
      }
      .readByteArray(),
  )

  /**
   * Gets the required size of an account for the given mint as a
   * little-endian `u64`.
   *
   * Return data can be fetched using `sol_get_return_data` and deserializing
   * the return data as a little-endian `u64`.
   */
  public fun getAccountDataSize(mint: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.GetAccountDataSize.index.toInt())
      .readByteArray(),
  )

  /**
   * Initialize the Immutable Owner extension for the given token account
   *
   * Fails if the account has already been initialized, so must be called
   * before `InitializeAccount`.
   *
   * No-ops in this version of the program, but is included for compatibility
   * with the Associated Token Account program.
   */
  public fun initializeImmutableOwner(account: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(account, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeImmutableOwner.index.toInt())
      .readByteArray(),
  )

  /**
   * Convert an Amount of tokens to a UiAmount `string`, using the given
   * mint. In this version of the program, the mint can only specify the
   * number of decimals.
   *
   * Fails on an invalid mint.
   *
   * Return data can be fetched using `sol_get_return_data` and deserialized
   * with `String::from_utf8`.
   */
  public fun amountToUiAmount(mint: PublicKey, amount: ULong): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.AmountToUiAmount.index.toInt())
      .writeLongLe(amount.toLong())
      .readByteArray(),
  )

  /**
   * Convert a UiAmount of tokens to a little-endian `u64` raw Amount, using
   * the given mint. In this version of the program, the mint can only
   * specify the number of decimals.
   *
   * Return data can be fetched using `sol_get_return_data` and deserializing
   * the return data as a little-endian `u64`.
   */
  public fun uiAmountToAmount(mint: PublicKey, uiAmount: String): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.UiAmountToAmount.index.toInt())
      .writeUtf8(uiAmount)
      .readByteArray(),
  )

  /**
   * Initialize the close account authority on a new mint.
   *
   * Fails if the mint has already been initialized, so must be called before `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82
   * bytes), plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeMintCloseAuthority(mint: PublicKey, closeAuthority: PublicKey?):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeMintCloseAuthority.index.toInt())
      .apply {
        if (closeAuthority != null) {
          writeByte(1)
          .write(closeAuthority.bytes)
        } else {
          writeByte(0)
        }
      }
      .readByteArray(),
  )

  /**
   * Initialize the transfer fee on a new mint.
   *
   * Fails if the mint has already been initialized, so must be called before `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82
   * bytes), plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeTransferFeeConfig(
    mint: PublicKey,
    transferFeeConfigAuthority: PublicKey?,
    withdrawWithheldAuthority: PublicKey?,
    transferFeeBasisPoints: UShort,
    maximumFee: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeTransferFeeConfig.index.toInt())
      .apply {
        if (transferFeeConfigAuthority != null) {
          writeByte(1)
          .write(transferFeeConfigAuthority.bytes)
        } else {
          writeByte(0)
        }
      }
      .apply {
        if (withdrawWithheldAuthority != null) {
          writeByte(1)
          .write(withdrawWithheldAuthority.bytes)
        } else {
          writeByte(0)
        }
      }
      .writeShortLe(transferFeeBasisPoints.toInt())
      .writeLongLe(maximumFee.toLong())
      .readByteArray(),
  )

  /**
   * Transfer, providing expected mint information and fees.
   *
   * This instruction succeeds if the mint has no configured transfer fee
   * and the provided fee is 0. This allows applications to use
   * `TransferCheckedWithFee` with any mint.
   */
  public fun transferCheckedWithFee(
    source: PublicKey,
    mint: PublicKey,
    destination: PublicKey,
    authority: PublicKey,
    amount: ULong,
    decimals: UByte,
    fee: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(source, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(destination, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.TransferCheckedWithFee.index.toInt())
      .writeLongLe(amount.toLong())
      .writeByte(decimals.toInt())
      .writeLongLe(fee.toLong())
      .readByteArray(),
  )

  /**
   * Transfer all withheld tokens in the mint to an account. Signed by the
   * mint's withdraw withheld tokens authority.
   */
  public fun withdrawWithheldTokensFromMint(
    mint: PublicKey,
    feeReceiver: PublicKey,
    withdrawWithheldAuthority: PublicKey,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(feeReceiver, isSigner = false, isWritable = true),
      AccountMeta(withdrawWithheldAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.WithdrawWithheldTokensFromMint.index.toInt())
      .readByteArray(),
  )

  /**
   * Transfer all withheld tokens to an account. Signed by the mint's
   * withdraw withheld tokens authority.
   */
  public fun withdrawWithheldTokensFromAccounts(
    mint: PublicKey,
    feeReceiver: PublicKey,
    withdrawWithheldAuthority: PublicKey,
    numTokenAccounts: UByte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(feeReceiver, isSigner = false, isWritable = true),
      AccountMeta(withdrawWithheldAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.WithdrawWithheldTokensFromAccounts.index.toInt())
      .writeByte(numTokenAccounts.toInt())
      .readByteArray(),
  )

  /**
   * Permissionless instruction to transfer all withheld tokens to the mint.
   *
   * Succeeds for frozen accounts.
   *
   * Accounts provided should include the `TransferFeeAmount` extension.
   * If not, the account is skipped.
   */
  public fun harvestWithheldTokensToMint(mint: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.HarvestWithheldTokensToMint.index.toInt())
      .readByteArray(),
  )

  /**
   * Set transfer fee. Only supported for mints that include the
   * `TransferFeeConfig` extension.
   */
  public fun setTransferFee(
    mint: PublicKey,
    transferFeeConfigAuthority: PublicKey,
    transferFeeBasisPoints: UShort,
    maximumFee: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(transferFeeConfigAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.SetTransferFee.index.toInt())
      .writeShortLe(transferFeeBasisPoints.toInt())
      .writeLongLe(maximumFee.toLong())
      .readByteArray(),
  )

  /**
   * Initializes confidential transfers for a mint.
   *
   * The `ConfidentialTransferInstruction::InitializeMint` instruction
   * requires no signers and MUST be included within the same Transaction
   * as `TokenInstruction::InitializeMint`. Otherwise another party can
   * initialize the configuration.
   *
   * The instruction fails if the `TokenInstruction::InitializeMint`
   * instruction has already executed for the mint.
   */
  public fun initializeConfidentialTransferMint(
    mint: PublicKey,
    authority: PublicKey?,
    autoApproveNewAccounts: Boolean,
    auditorElgamalPubkey: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeConfidentialTransferMint.index.toInt())
      .apply {
        if (authority != null) {
          write(authority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .writeByte(if (autoApproveNewAccounts) 1 else 0)
      .apply {
        if (auditorElgamalPubkey != null) {
          write(auditorElgamalPubkey.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Updates the confidential transfer mint configuration for a mint.
   *
   * Use `TokenInstruction::SetAuthority` to update the confidential transfer
   * mint authority.
   */
  public fun updateConfidentialTransferMint(
    mint: PublicKey,
    authority: PublicKey,
    autoApproveNewAccounts: Boolean,
    auditorElgamalPubkey: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.UpdateConfidentialTransferMint.index.toInt())
      .writeByte(if (autoApproveNewAccounts) 1 else 0)
      .apply {
        if (auditorElgamalPubkey != null) {
          write(auditorElgamalPubkey.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Configures confidential transfers for a token account.
   *
   * The instruction fails if the confidential transfers are already
   * configured, or if the mint was not initialized with confidential
   * transfer support.
   *
   * The instruction fails if the `TokenInstruction::InitializeAccount`
   * instruction has not yet successfully executed for the token account.
   *
   * Upon success, confidential and non-confidential deposits and transfers
   * are enabled. Use the `DisableConfidentialCredits` and
   * `DisableNonConfidentialCredits` instructions to disable.
   *
   * In order for this instruction to be successfully processed, it must be
   * accompanied by the `VerifyPubkeyValidity` instruction of the
   * `zk_elgamal_proof` program in the same transaction or the address of a
   * context state account for the proof must be provided.
   */
  public fun configureConfidentialTransferAccount(
    token: PublicKey,
    mint: PublicKey,
    record: PublicKey,
    authority: PublicKey,
    decryptableZeroBalance: DecryptableBalance,
    maximumPendingBalanceCreditCounter: ULong,
    proofInstructionOffset: Byte,
    instructionsSysvarOrContextState: PublicKey = INSTRUCTIONS_SYSVAR_OR_CONTEXT_STATE,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(instructionsSysvarOrContextState, isSigner = false, isWritable = false),
      AccountMeta(record, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ConfigureConfidentialTransferAccount.index.toInt())
      .write(decryptableZeroBalance.bytes)
      .writeLongLe(maximumPendingBalanceCreditCounter.toLong())
      .writeByte(proofInstructionOffset.toInt())
      .readByteArray(),
  )

  /**
   * Approves a token account for confidential transfers.
   *
   * Approval is only required when the
   * `ConfidentialTransferMint::approve_new_accounts` field is set in the
   * SPL Token mint.  This instruction must be executed after the account
   * owner configures their account for confidential transfers with
   * `ConfidentialTransferInstruction::ConfigureAccount`.
   */
  public fun approveConfidentialTransferAccount(
    token: PublicKey,
    mint: PublicKey,
    authority: PublicKey,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ApproveConfidentialTransferAccount.index.toInt())
      .readByteArray(),
  )

  /**
   * Empty the available balance in a confidential token account.
   *
   * A token account that is extended for confidential transfers can only be
   * closed if the pending and available balance ciphertexts are emptied.
   * The pending balance can be emptied
   * via the `ConfidentialTransferInstruction::ApplyPendingBalance`
   * instruction. Use the `ConfidentialTransferInstruction::EmptyAccount`
   * instruction to empty the available balance ciphertext.
   *
   * Note that a newly configured account is always empty, so this
   * instruction is not required prior to account closing if no
   * instructions beyond
   * `ConfidentialTransferInstruction::ConfigureAccount` have affected the
   * token account.
   *
   * In order for this instruction to be successfully processed, it must be
   * accompanied by the `VerifyZeroCiphertext` instruction of the
   * `zk_elgamal_proof` program in the same transaction or the address of a
   * context state account for the proof must be provided.
   */
  public fun emptyConfidentialTransferAccount(
    token: PublicKey,
    record: PublicKey,
    authority: PublicKey,
    proofInstructionOffset: Byte,
    instructionsSysvarOrContextState: PublicKey = INSTRUCTIONS_SYSVAR_OR_CONTEXT_STATE,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(instructionsSysvarOrContextState, isSigner = false, isWritable = false),
      AccountMeta(record, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.EmptyConfidentialTransferAccount.index.toInt())
      .writeByte(proofInstructionOffset.toInt())
      .readByteArray(),
  )

  /**
   * Deposit SPL Tokens into the pending balance of a confidential token
   * account.
   *
   * The account owner can then invoke the `ApplyPendingBalance` instruction
   * to roll the deposit into their available balance at a time of their
   * choosing.
   *
   * Fails if the source or destination accounts are frozen.
   * Fails if the associated mint is extended as `NonTransferable`.
   */
  public fun confidentialDeposit(
    token: PublicKey,
    mint: PublicKey,
    authority: PublicKey,
    amount: ULong,
    decimals: UByte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ConfidentialDeposit.index.toInt())
      .writeLongLe(amount.toLong())
      .writeByte(decimals.toInt())
      .readByteArray(),
  )

  /**
   * Withdraw SPL Tokens from the available balance of a confidential token
   * account.
   *
   * In order for this instruction to be successfully processed, it must be
   * accompanied by the following list of `zk_elgamal_proof` program
   * instructions:
   * - `VerifyCiphertextCommitmentEquality`
   * - `VerifyBatchedRangeProofU64`
   * These instructions can be accompanied in the same transaction or can be
   * pre-verified into a context state account, in which case, only their
   * context state account address need to be provided.
   *
   * Fails if the source or destination accounts are frozen.
   * Fails if the associated mint is extended as `NonTransferable`.
   */
  public fun confidentialWithdraw(
    token: PublicKey,
    mint: PublicKey,
    instructionsSysvar: PublicKey,
    equalityRecord: PublicKey,
    rangeRecord: PublicKey,
    authority: PublicKey,
    amount: ULong,
    decimals: UByte,
    newDecryptableAvailableBalance: DecryptableBalance,
    equalityProofInstructionOffset: Byte,
    rangeProofInstructionOffset: Byte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(instructionsSysvar, isSigner = false, isWritable = false),
      AccountMeta(equalityRecord, isSigner = false, isWritable = false),
      AccountMeta(rangeRecord, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ConfidentialWithdraw.index.toInt())
      .writeLongLe(amount.toLong())
      .writeByte(decimals.toInt())
      .write(newDecryptableAvailableBalance.bytes)
      .writeByte(equalityProofInstructionOffset.toInt())
      .writeByte(rangeProofInstructionOffset.toInt())
      .readByteArray(),
  )

  /**
   * Transfer tokens confidentially.
   *
   * In order for this instruction to be successfully processed, it must be
   * accompanied by the following list of `zk_elgamal_proof` program
   * instructions:
   * - `VerifyCiphertextCommitmentEquality`
   * - `VerifyBatchedGroupedCiphertext3HandlesValidity`
   * - `VerifyBatchedRangeProofU128`
   * These instructions can be accompanied in the same transaction or can be
   * pre-verified into a context state account, in which case, only their
   * context state account addresses need to be provided.
   *
   * Fails if the associated mint is extended as `NonTransferable`.
   */
  public fun confidentialTransfer(
    sourceToken: PublicKey,
    mint: PublicKey,
    destinationToken: PublicKey,
    instructionsSysvar: PublicKey,
    equalityRecord: PublicKey,
    ciphertextValidityRecord: PublicKey,
    rangeRecord: PublicKey,
    authority: PublicKey,
    newSourceDecryptableAvailableBalance: DecryptableBalance,
    equalityProofInstructionOffset: Byte,
    ciphertextValidityProofInstructionOffset: Byte,
    rangeProofInstructionOffset: Byte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(sourceToken, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(destinationToken, isSigner = false, isWritable = true),
      AccountMeta(instructionsSysvar, isSigner = false, isWritable = false),
      AccountMeta(equalityRecord, isSigner = false, isWritable = false),
      AccountMeta(ciphertextValidityRecord, isSigner = false, isWritable = false),
      AccountMeta(rangeRecord, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ConfidentialTransfer.index.toInt())
      .write(newSourceDecryptableAvailableBalance.bytes)
      .writeByte(equalityProofInstructionOffset.toInt())
      .writeByte(ciphertextValidityProofInstructionOffset.toInt())
      .writeByte(rangeProofInstructionOffset.toInt())
      .readByteArray(),
  )

  /**
   * Applies the pending balance to the available balance, based on the
   * history of `Deposit` and/or `Transfer` instructions.
   *
   * After submitting `ApplyPendingBalance`, the client should compare
   * `ConfidentialTransferAccount::expected_pending_balance_credit_counter`
   * with
   * `ConfidentialTransferAccount::actual_applied_pending_balance_instructions`.  If they are
   * equal then the
   * `ConfidentialTransferAccount::decryptable_available_balance` is
   * consistent with `ConfidentialTransferAccount::available_balance`. If
   * they differ then there is more pending balance to be applied.
   */
  public fun applyConfidentialPendingBalance(
    token: PublicKey,
    authority: PublicKey,
    expectedPendingBalanceCreditCounter: ULong,
    newDecryptableAvailableBalance: DecryptableBalance,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ApplyConfidentialPendingBalance.index.toInt())
      .writeLongLe(expectedPendingBalanceCreditCounter.toLong())
      .write(newDecryptableAvailableBalance.bytes)
      .readByteArray(),
  )

  /**
   * Configure a confidential extension account to accept incoming
   * confidential transfers.
   */
  public fun enableConfidentialCredits(token: PublicKey, authority: PublicKey):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.EnableConfidentialCredits.index.toInt())
      .readByteArray(),
  )

  /**
   * Configure a confidential extension account to reject any incoming
   * confidential transfers.
   *
   * If the `allow_non_confidential_credits` field is `true`, then the base
   * account can still receive non-confidential transfers.
   *
   * This instruction can be used to disable confidential payments after a
   * token account has already been extended for confidential transfers.
   */
  public fun disableConfidentialCredits(token: PublicKey, authority: PublicKey):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.DisableConfidentialCredits.index.toInt())
      .readByteArray(),
  )

  /**
   * Configure an account with the confidential extension to accept incoming
   * non-confidential transfers.
   */
  public fun enableNonConfidentialCredits(token: PublicKey, authority: PublicKey):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.EnableNonConfidentialCredits.index.toInt())
      .readByteArray(),
  )

  /**
   * Configure an account with the confidential extension to reject any
   * incoming non-confidential transfers.
   *
   * This instruction can be used to configure a confidential extension
   * account to exclusively receive confidential payments.
   */
  public fun disableNonConfidentialCredits(token: PublicKey, authority: PublicKey):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.DisableNonConfidentialCredits.index.toInt())
      .readByteArray(),
  )

  /**
   * Transfer tokens confidentially with fee.
   *
   * In order for this instruction to be successfully processed, it must be
   * accompanied by the following list of `zk_elgamal_proof` program
   * instructions:
   * - `VerifyCiphertextCommitmentEquality`
   * - `VerifyBatchedGroupedCiphertext3HandlesValidity` (transfer amount
   *   ciphertext)
   * - `VerifyPercentageWithFee`
   * - `VerifyBatchedGroupedCiphertext2HandlesValidity` (fee ciphertext)
   * - `VerifyBatchedRangeProofU256`
   * These instructions can be accompanied in the same transaction or can be
   * pre-verified into a context state account, in which case, only their
   * context state account addresses need to be provided.
   *
   * The same restrictions for the `Transfer` applies to
   * `TransferWithFee`. Namely, the instruction fails if the
   * associated mint is extended as `NonTransferable`.
   */
  public fun confidentialTransferWithFee(
    sourceToken: PublicKey,
    mint: PublicKey,
    destinationToken: PublicKey,
    instructionsSysvar: PublicKey,
    equalityRecord: PublicKey,
    transferAmountCiphertextValidityRecord: PublicKey,
    feeSigmaRecord: PublicKey,
    feeCiphertextValidityRecord: PublicKey,
    rangeRecord: PublicKey,
    authority: PublicKey,
    newSourceDecryptableAvailableBalance: DecryptableBalance,
    equalityProofInstructionOffset: Byte,
    transferAmountCiphertextValidityProofInstructionOffset: Byte,
    feeSigmaProofInstructionOffset: Byte,
    feeCiphertextValidityProofInstructionOffset: Byte,
    rangeProofInstructionOffset: Byte,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(sourceToken, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(destinationToken, isSigner = false, isWritable = true),
      AccountMeta(instructionsSysvar, isSigner = false, isWritable = false),
      AccountMeta(equalityRecord, isSigner = false, isWritable = false),
      AccountMeta(transferAmountCiphertextValidityRecord, isSigner = false, isWritable = false),
      AccountMeta(feeSigmaRecord, isSigner = false, isWritable = false),
      AccountMeta(feeCiphertextValidityRecord, isSigner = false, isWritable = false),
      AccountMeta(rangeRecord, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.ConfidentialTransferWithFee.index.toInt())
      .write(newSourceDecryptableAvailableBalance.bytes)
      .writeByte(equalityProofInstructionOffset.toInt())
      .writeByte(transferAmountCiphertextValidityProofInstructionOffset.toInt())
      .writeByte(feeSigmaProofInstructionOffset.toInt())
      .writeByte(feeCiphertextValidityProofInstructionOffset.toInt())
      .writeByte(rangeProofInstructionOffset.toInt())
      .readByteArray(),
  )

  /**
   * Initialize a new mint with the default state for new Accounts.
   *
   * Fails if the mint has already been initialized, so must be called before
   * `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82
   * bytes), plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeDefaultAccountState(mint: PublicKey, state: AccountState):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeDefaultAccountState.index.toInt())
      .writeByte(state.value.toInt())
      .readByteArray(),
  )

  /**
   * Update the default state for new Accounts. Only supported for mints that
   * include the `DefaultAccountState` extension.
   */
  public fun updateDefaultAccountState(
    mint: PublicKey,
    freezeAuthority: PublicKey,
    state: AccountState,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(freezeAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.UpdateDefaultAccountState.index.toInt())
      .writeByte(state.value.toInt())
      .readByteArray(),
  )

  /**
   * Check to see if a token account is large enough for a list of
   * ExtensionTypes, and if not, use reallocation to increase the data
   * size.
   */
  public fun reallocate(
    token: PublicKey,
    payer: PublicKey,
    owner: PublicKey,
    newExtensionTypes: List<ExtensionType>,
    systemProgram: PublicKey = SystemProgram.programId,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(payer, isSigner = true, isWritable = true),
      AccountMeta(systemProgram, isSigner = false, isWritable = false),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.Reallocate.index.toInt())
      .apply {
        newExtensionTypes.forEach { item ->
          writeByte(item.value.toInt())
        }
      }
      .readByteArray(),
  )

  /**
   * Require memos for transfers into this Account. Adds the MemoTransfer
   * extension to the Account, if it doesn't already exist.
   */
  public fun enableMemoTransfers(token: PublicKey, owner: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.EnableMemoTransfers.index.toInt())
      .readByteArray(),
  )

  /**
   * Stop requiring memos for transfers into this Account.
   *
   * Implicitly initializes the extension in the case where it is not
   * present.
   */
  public fun disableMemoTransfers(token: PublicKey, owner: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.DisableMemoTransfers.index.toInt())
      .readByteArray(),
  )

  /**
   * Creates the native mint.
   *
   * This instruction only needs to be invoked once after deployment and is
   * permissionless. Wrapped SOL (`native_mint::id()`) will not be
   * available until this instruction is successfully executed.
   */
  public fun createNativeMint(
    payer: PublicKey,
    nativeMint: PublicKey,
    systemProgram: PublicKey = SystemProgram.programId,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(payer, isSigner = true, isWritable = true),
      AccountMeta(nativeMint, isSigner = false, isWritable = true),
      AccountMeta(systemProgram, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.CreateNativeMint.index.toInt())
      .readByteArray(),
  )

  /**
   * Initialize the non transferable extension for the given mint account
   *
   * Fails if the account has already been initialized, so must be called before `InitializeMint`.
   */
  public fun initializeNonTransferableMint(mint: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeNonTransferableMint.index.toInt())
      .readByteArray(),
  )

  /**
   * Initialize a new mint with the `InterestBearing` extension.
   *
   * Fails if the mint has already been initialized, so must be called before
   * `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82
   * bytes), plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeInterestBearingMint(
    mint: PublicKey,
    rateAuthority: PublicKey?,
    rate: Short,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeInterestBearingMint.index.toInt())
      .apply {
        if (rateAuthority != null) {
          write(rateAuthority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .writeShortLe(rate.toInt())
      .readByteArray(),
  )

  /**
   * Update the interest rate. Only supported for mints that include the
   * `InterestBearingConfig` extension.
   */
  public fun updateRateInterestBearingMint(
    mint: PublicKey,
    rateAuthority: PublicKey,
    rate: Short,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(rateAuthority, isSigner = true, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.UpdateRateInterestBearingMint.index.toInt())
      .writeShortLe(rate.toInt())
      .readByteArray(),
  )

  /**
   * Lock certain token operations from taking place within CPI for this Account, namely:
   * * Transfer and Burn must go through a delegate.
   * * CloseAccount can only return lamports to owner.
   * * SetAuthority can only be used to remove an existing close authority.
   * * Approve is disallowed entirely.
   *
   * In addition, CPI Guard cannot be enabled or disabled via CPI.
   */
  public fun enableCpiGuard(token: PublicKey, owner: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.EnableCpiGuard.index.toInt())
      .readByteArray(),
  )

  /**
   * Allow all token operations to happen via CPI as normal.
   *
   * Implicitly initializes the extension in the case where it is not present.
   */
  public fun disableCpiGuard(token: PublicKey, owner: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(token, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.DisableCpiGuard.index.toInt())
      .readByteArray(),
  )

  /**
   * Initialize the permanent delegate on a new mint.
   *
   * Fails if the mint has already been initialized, so must be called before `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82 bytes),
   * plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializePermanentDelegate(mint: PublicKey, `delegate`: PublicKey):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializePermanentDelegate.index.toInt())
      .write(delegate.bytes)
      .readByteArray(),
  )

  /**
   * Initialize a new mint with a transfer hook program.
   *
   * Fails if the mint has already been initialized, so must be called before `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82 bytes),
   * plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeTransferHook(
    mint: PublicKey,
    authority: PublicKey?,
    targetProgramId: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeTransferHook.index.toInt())
      .apply {
        if (authority != null) {
          write(authority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .apply {
        if (targetProgramId != null) {
          write(targetProgramId.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Update the transfer hook program id. Only supported for mints that
   * include the `TransferHook` extension.
   *
   * Accounts expected by this instruction:
   *
   *   0. `[writable]` The mint.
   *   1. `[signer]` The transfer hook authority.
   */
  public fun updateTransferHook(
    mint: PublicKey,
    authority: PublicKey,
    targetProgramId: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.UpdateTransferHook.index.toInt())
      .apply {
        if (targetProgramId != null) {
          write(targetProgramId.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Initializes confidential transfer fees for a mint.
   *
   * The instruction must be included within the same Transaction as
   * TokenInstruction::InitializeMint.
   * Otherwise another party can initialize the configuration.
   *
   * The instruction fails if TokenInstruction::InitializeMint has already executed for the mint.
   */
  public fun initializeConfidentialTransferFee(
    mint: PublicKey,
    authority: PublicKey?,
    withdrawWithheldAuthorityElGamalPubkey: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeConfidentialTransferFee.index.toInt())
      .apply {
        if (authority != null) {
          write(authority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .apply {
        if (withdrawWithheldAuthorityElGamalPubkey != null) {
          write(withdrawWithheldAuthorityElGamalPubkey.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Transfer all withheld confidential tokens in the mint to an account.
   * Signed by the mint's withdraw withheld tokens authority.
   *
   * The withheld confidential tokens are aggregated directly into the destination available
   * balance.
   *
   * Must be accompanied by the VerifyCiphertextCiphertextEquality instruction
   * of the zk_elgamal_proof program in the same transaction or the address of
   * a context state account for the proof must be provided.
   */
  public fun withdrawWithheldTokensFromMintForConfidentialTransferFee(
    mint: PublicKey,
    destination: PublicKey,
    instructionsSysvarOrContextState: PublicKey,
    record: PublicKey,
    authority: PublicKey,
    proofInstructionOffset: Byte,
    newDecryptableAvailableBalance: DecryptableBalance,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(destination, isSigner = false, isWritable = true),
      AccountMeta(instructionsSysvarOrContextState, isSigner = false, isWritable = false),
      AccountMeta(record, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee.index.toInt())
      .writeByte(proofInstructionOffset.toInt())
      .write(newDecryptableAvailableBalance.bytes)
      .readByteArray(),
  )

  /**
   * Transfer all withheld tokens to an account. Signed by the mint's withdraw withheld
   * tokens authority. This instruction is susceptible to front-running.
   * Use `HarvestWithheldTokensToMint` and `WithdrawWithheldTokensFromMint` as alternative.
   *
   * Must be accompanied by the VerifyWithdrawWithheldTokens instruction.
   */
  public fun withdrawWithheldTokensFromAccountsForConfidentialTransferFee(
    mint: PublicKey,
    destination: PublicKey,
    instructionsSysvarOrContextState: PublicKey,
    record: PublicKey,
    authority: PublicKey,
    numTokenAccounts: UByte,
    proofInstructionOffset: Byte,
    newDecryptableAvailableBalance: DecryptableBalance,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(destination, isSigner = false, isWritable = true),
      AccountMeta(instructionsSysvarOrContextState, isSigner = false, isWritable = false),
      AccountMeta(record, isSigner = false, isWritable = false),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee.index.toInt())
      .writeByte(numTokenAccounts.toInt())
      .writeByte(proofInstructionOffset.toInt())
      .write(newDecryptableAvailableBalance.bytes)
      .readByteArray(),
  )

  /**
   * Permissionless instruction to transfer all withheld confidential tokens to the mint.
   *
   * Succeeds for frozen accounts.
   *
   * Accounts provided should include both the `TransferFeeAmount` and
   * `ConfidentialTransferAccount` extension. If not, the account is skipped.
   */
  public fun harvestWithheldTokensToMintForConfidentialTransferFee(mint: PublicKey):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee.index.toInt())
      .readByteArray(),
  )

  /**
   * Configure a confidential transfer fee mint to accept harvested confidential fees.
   */
  public fun enableHarvestToMint(mint: PublicKey, authority: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.EnableHarvestToMint.index.toInt())
      .readByteArray(),
  )

  /**
   * Configure a confidential transfer fee mint to reject any harvested confidential fees.
   */
  public fun disableHarvestToMint(mint: PublicKey, authority: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.DisableHarvestToMint.index.toInt())
      .readByteArray(),
  )

  /**
   * This instruction is to be used to rescue SOLs sent to any TokenProgram
   * owned account by sending them to any other account, leaving behind only
   * lamports for rent exemption.
   */
  public fun withdrawExcessLamports(
    sourceAccount: PublicKey,
    destinationAccount: PublicKey,
    authority: PublicKey,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(sourceAccount, isSigner = false, isWritable = true),
      AccountMeta(destinationAccount, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.WithdrawExcessLamports.index.toInt())
      .readByteArray(),
  )

  /**
   * Initialize a new mint with a metadata pointer
   *
   * Fails if the mint has already been initialized, so must be called before
   * `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82
   * bytes), plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeMetadataPointer(
    mint: PublicKey,
    authority: PublicKey?,
    metadataAddress: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeMetadataPointer.index.toInt())
      .apply {
        if (authority != null) {
          write(authority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .apply {
        if (metadataAddress != null) {
          write(metadataAddress.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Update the metadata pointer address. Only supported for mints that
   * include the `MetadataPointer` extension.
   */
  public fun updateMetadataPointer(
    mint: PublicKey,
    metadataPointerAuthority: PublicKey,
    metadataAddress: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(metadataPointerAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.UpdateMetadataPointer.index.toInt())
      .apply {
        if (metadataAddress != null) {
          write(metadataAddress.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Initialize a new mint with a group pointer
   *
   * Fails if the mint has already been initialized, so must be called before
   * `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82
   * bytes), plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeGroupPointer(
    mint: PublicKey,
    authority: PublicKey?,
    groupAddress: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeGroupPointer.index.toInt())
      .apply {
        if (authority != null) {
          write(authority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .apply {
        if (groupAddress != null) {
          write(groupAddress.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Update the group pointer address. Only supported for mints that
   * include the `GroupPointer` extension.
   */
  public fun updateGroupPointer(
    mint: PublicKey,
    groupPointerAuthority: PublicKey,
    groupAddress: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(groupPointerAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.UpdateGroupPointer.index.toInt())
      .apply {
        if (groupAddress != null) {
          write(groupAddress.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Initialize a new mint with a group member pointer
   *
   * Fails if the mint has already been initialized, so must be called before
   * `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82
   * bytes), plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeGroupMemberPointer(
    mint: PublicKey,
    authority: PublicKey?,
    memberAddress: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeGroupMemberPointer.index.toInt())
      .apply {
        if (authority != null) {
          write(authority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .apply {
        if (memberAddress != null) {
          write(memberAddress.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Update the group member pointer address. Only supported for mints that
   * include the `GroupMemberPointer` extension.
   */
  public fun updateGroupMemberPointer(
    mint: PublicKey,
    groupMemberPointerAuthority: PublicKey,
    memberAddress: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(groupMemberPointerAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.UpdateGroupMemberPointer.index.toInt())
      .apply {
        if (memberAddress != null) {
          write(memberAddress.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Initialize a new mint with the `ScaledUiAmount` extension.
   *
   * Fails if the mint has already been initialized, so must be called before `InitializeMint`.
   *
   * The mint must have exactly enough space allocated for the base mint (82 bytes),
   * plus 83 bytes of padding, 1 byte reserved for the account type,
   * then space required for this extension, plus any others.
   */
  public fun initializeScaledUiAmountMint(
    mint: PublicKey,
    authority: PublicKey?,
    multiplier: Double,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializeScaledUiAmountMint.index.toInt())
      .apply {
        if (authority != null) {
          write(authority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .writeLongLe(multiplier.toRawBits())
      .readByteArray(),
  )

  /**
   * Update the multiplier. Only supported for mints that include the
   * `ScaledUiAmountConfig` extension.
   * You can set a specific timestamp for the multiplier to take effect.
   */
  public fun updateMultiplierScaledUiMint(
    mint: PublicKey,
    authority: PublicKey,
    multiplier: Double,
    effectiveTimestamp: Long,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.UpdateMultiplierScaledUiMint.index.toInt())
      .writeLongLe(multiplier.toRawBits())
      .writeLongLe(effectiveTimestamp)
      .readByteArray(),
  )

  /**
   * Initialize a new mint with the `Pausable` extension.
   *
   * Fails if the mint has already been initialized, so must be called before `InitializeMint`.
   */
  public fun initializePausableConfig(mint: PublicKey, authority: PublicKey?):
      TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
    ),
    data = Buffer()
      .writeByte(Instruction.InitializePausableConfig.index.toInt())
      .apply {
        if (authority != null) {
          write(authority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Pause the mint.
   *
   * Fails if the mint is not pausable.
   */
  public fun pause(mint: PublicKey, authority: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.Pause.index.toInt())
      .readByteArray(),
  )

  /**
   * Resume the mint.
   *
   * Fails if the mint is not pausable.
   */
  public fun resume(mint: PublicKey, authority: PublicKey): TransactionInstruction =
      createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(mint, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.Resume.index.toInt())
      .readByteArray(),
  )

  /**
   * Initializes a TLV entry with the basic token-metadata fields.
   *
   * Assumes that the provided mint is an SPL token mint, that the metadata
   * account is allocated and assigned to the program, and that the metadata
   * account has enough lamports to cover the rent-exempt reserve.
   */
  public fun initializeTokenMetadata(
    metadata: PublicKey,
    updateAuthority: PublicKey,
    mint: PublicKey,
    mintAuthority: PublicKey,
    name: String,
    symbol: String,
    uri: String,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(metadata, isSigner = false, isWritable = true),
      AccountMeta(updateAuthority, isSigner = false, isWritable = false),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(mintAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0xd2.toByte(), 0xe1.toByte(), 0x1e.toByte(), 0xa2.toByte(), 0x58.toByte(),
          0xb8.toByte(), 0x4d.toByte(), 0x8d.toByte()))
      .apply {
        val bytes = name.encodeToByteArray()
        writeIntLe(bytes.size)
        write(bytes)
      }
      .apply {
        val bytes = symbol.encodeToByteArray()
        writeIntLe(bytes.size)
        write(bytes)
      }
      .apply {
        val bytes = uri.encodeToByteArray()
        writeIntLe(bytes.size)
        write(bytes)
      }
      .readByteArray(),
  )

  /**
   * Updates a field in a token-metadata account.
   *
   * The field can be one of the required fields (name, symbol, URI), or a
   * totally new field denoted by a "key" string.
   *
   * By the end of the instruction, the metadata account must be properly
   * resized based on the new size of the TLV entry.
   *   * If the new size is larger, the program must first reallocate to
   *     avoid
   *   overwriting other TLV entries.
   *   * If the new size is smaller, the program must reallocate at the end
   *   so that it's possible to iterate over TLV entries
   */
  public fun updateTokenMetadataField(
    metadata: PublicKey,
    updateAuthority: PublicKey,
    `field`: TokenMetadataField,
    `value`: String,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(metadata, isSigner = false, isWritable = true),
      AccountMeta(updateAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0xdd.toByte(), 0xe9.toByte(), 0x31.toByte(), 0x2d.toByte(), 0xb5.toByte(),
          0xca.toByte(), 0xdc.toByte(), 0xc8.toByte()))
      .write(field.serialize())
      .apply {
        val bytes = value.encodeToByteArray()
        writeIntLe(bytes.size)
        write(bytes)
      }
      .readByteArray(),
  )

  /**
   * Removes a key-value pair in a token-metadata account.
   *
   * This only applies to additional fields, and not the base name / symbol /
   * URI fields.
   *
   * By the end of the instruction, the metadata account must be properly
   * resized at the end based on the new size of the TLV entry.
   */
  public fun removeTokenMetadataKey(
    metadata: PublicKey,
    updateAuthority: PublicKey,
    idempotent: Boolean,
    key: String,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(metadata, isSigner = false, isWritable = true),
      AccountMeta(updateAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0xea.toByte(), 0x12.toByte(), 0x20.toByte(), 0x38.toByte(), 0x59.toByte(),
          0x8d.toByte(), 0x25.toByte(), 0xb5.toByte()))
      .writeByte(if (idempotent) 1 else 0)
      .apply {
        val bytes = key.encodeToByteArray()
        writeIntLe(bytes.size)
        write(bytes)
      }
      .readByteArray(),
  )

  /**
   * Updates the token-metadata authority.
   */
  public fun updateTokenMetadataUpdateAuthority(
    metadata: PublicKey,
    updateAuthority: PublicKey,
    newUpdateAuthority: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(metadata, isSigner = false, isWritable = true),
      AccountMeta(updateAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0xd7.toByte(), 0xe4.toByte(), 0xa6.toByte(), 0xe4.toByte(), 0x54.toByte(),
          0x64.toByte(), 0x56.toByte(), 0x7b.toByte()))
      .apply {
        if (newUpdateAuthority != null) {
          write(newUpdateAuthority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Emits the token-metadata as return data
   *
   * The format of the data emitted follows exactly the `TokenMetadata`
   * struct, but it's possible that the account data is stored in another
   * format by the program.
   *
   * With this instruction, a program that implements the token-metadata
   * interface can return `TokenMetadata` without adhering to the specific
   * byte layout of the `TokenMetadata` struct in any accounts.
   */
  public fun emitTokenMetadata(
    metadata: PublicKey,
    start: ULong?,
    end: ULong?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(metadata, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0xfa.toByte(), 0xa6.toByte(), 0xb4.toByte(), 0xfa.toByte(), 0x0d.toByte(),
          0x0c.toByte(), 0xb8.toByte(), 0x46.toByte()))
      .apply {
        if (start != null) {
          writeByte(1)
          .writeLongLe(start.toLong())
        } else {
          writeByte(0)
        }
      }
      .apply {
        if (end != null) {
          writeByte(1)
          .writeLongLe(end.toLong())
        } else {
          writeByte(0)
        }
      }
      .readByteArray(),
  )

  /**
   * Initialize a new `Group`
   *
   * Assumes one has already initialized a mint for the group.
   */
  public fun initializeTokenGroup(
    group: PublicKey,
    mint: PublicKey,
    mintAuthority: PublicKey,
    updateAuthority: PublicKey?,
    maxSize: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(group, isSigner = false, isWritable = true),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(mintAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0x79.toByte(), 0x71.toByte(), 0x6c.toByte(), 0x27.toByte(), 0x36.toByte(),
          0x33.toByte(), 0x00.toByte(), 0x04.toByte()))
      .apply {
        if (updateAuthority != null) {
          write(updateAuthority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .writeLongLe(maxSize.toLong())
      .readByteArray(),
  )

  /**
   * Update the max size of a `Group`.
   */
  public fun updateTokenGroupMaxSize(
    group: PublicKey,
    updateAuthority: PublicKey,
    maxSize: ULong,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(group, isSigner = false, isWritable = true),
      AccountMeta(updateAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0x6c.toByte(), 0x25.toByte(), 0xab.toByte(), 0x8f.toByte(), 0xf8.toByte(),
          0x1e.toByte(), 0x12.toByte(), 0x6e.toByte()))
      .writeLongLe(maxSize.toLong())
      .readByteArray(),
  )

  /**
   * Update the authority of a `Group`.
   */
  public fun updateTokenGroupUpdateAuthority(
    group: PublicKey,
    updateAuthority: PublicKey,
    newUpdateAuthority: PublicKey?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(group, isSigner = false, isWritable = true),
      AccountMeta(updateAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0xa1.toByte(), 0x69.toByte(), 0x58.toByte(), 0x01.toByte(), 0xed.toByte(),
          0xdd.toByte(), 0xd8.toByte(), 0xcb.toByte()))
      .apply {
        if (newUpdateAuthority != null) {
          write(newUpdateAuthority.bytes)
        } else {
          write(ByteArray(32))
        }
      }
      .readByteArray(),
  )

  /**
   * Initialize a new `Member` of a `Group`
   *
   * Assumes the `Group` has already been initialized,
   * as well as the mint for the member.
   */
  public fun initializeTokenGroupMember(
    member: PublicKey,
    memberMint: PublicKey,
    memberMintAuthority: PublicKey,
    group: PublicKey,
    groupUpdateAuthority: PublicKey,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(member, isSigner = false, isWritable = true),
      AccountMeta(memberMint, isSigner = false, isWritable = false),
      AccountMeta(memberMintAuthority, isSigner = true, isWritable = false),
      AccountMeta(group, isSigner = false, isWritable = true),
      AccountMeta(groupUpdateAuthority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .write(byteArrayOf(0x98.toByte(), 0x20.toByte(), 0xde.toByte(), 0xb0.toByte(), 0xdf.toByte(),
          0xed.toByte(), 0x74.toByte(), 0x86.toByte()))
      .readByteArray(),
  )

  /**
   * Transfer lamports from a native SOL account to a destination account.
   */
  public fun unwrapLamports(
    source: PublicKey,
    destination: PublicKey,
    authority: PublicKey,
    amount: ULong?,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(source, isSigner = false, isWritable = true),
      AccountMeta(destination, isSigner = false, isWritable = true),
      AccountMeta(authority, isSigner = true, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.UnwrapLamports.index.toInt())
      .apply {
        if (amount != null) {
          writeByte(1)
          .writeLongLe(amount.toLong())
        } else {
          writeByte(0)
        }
      }
      .readByteArray(),
  )

  public enum class AccountState(
    public val `value`: UByte,
  ) {
    Uninitialized(0u),
    Initialized(1u),
    Frozen(2u),
    ;
  }

  public enum class AuthorityType(
    public val `value`: UByte,
  ) {
    MintTokens(0u),
    FreezeAccount(1u),
    AccountOwner(2u),
    CloseAccount(3u),
    TransferFeeConfig(4u),
    WithheldWithdraw(5u),
    CloseMint(6u),
    InterestRate(7u),
    PermanentDelegate(8u),
    ConfidentialTransferMint(9u),
    TransferHookProgramId(10u),
    ConfidentialTransferFeeConfig(11u),
    MetadataPointer(12u),
    GroupPointer(13u),
    GroupMemberPointer(14u),
    ScaledUiAmount(15u),
    Pause(16u),
    ;
  }

  public data class TransferFee(
    public val epoch: ULong,
    public val maximumFee: ULong,
    public val transferFeeBasisPoints: UShort,
  ) {
    public fun serialize(): ByteArray {
      val buffer = Buffer()
      buffer.writeLongLe(epoch.toLong())
      buffer.writeLongLe(maximumFee.toLong())
      buffer.writeShortLe(transferFeeBasisPoints.toInt())
      return buffer.readByteArray()
    }
  }

  @JvmInline
  public value class EncryptedBalance(
    public val bytes: ByteArray,
  ) {
    init {
      require(bytes.size == 64) { "EncryptedBalance must be 64 bytes" }
    }
  }

  @JvmInline
  public value class DecryptableBalance(
    public val bytes: ByteArray,
  ) {
    init {
      require(bytes.size == 36) { "DecryptableBalance must be 36 bytes" }
    }
  }

  public sealed class Extension {
    public abstract fun serialize(): ByteArray

    public object Uninitialized : Extension() {
      public override fun serialize(): ByteArray = byteArrayOf(0.toByte())
    }

    public data class TransferFeeConfig(
      public val transferFeeConfigAuthority: PublicKey,
      public val withdrawWithheldAuthority: PublicKey,
      public val withheldAmount: ULong,
      public val olderTransferFee: TransferFee,
      public val newerTransferFee: TransferFee,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(1)
        buffer.write(transferFeeConfigAuthority.bytes)
        buffer.write(withdrawWithheldAuthority.bytes)
        buffer.writeLongLe(withheldAmount.toLong())
        buffer.write(olderTransferFee.serialize())
        buffer.write(newerTransferFee.serialize())
        return buffer.readByteArray()
      }
    }

    public data class TransferFeeAmount(
      public val withheldAmount: ULong,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(2)
        buffer.writeLongLe(withheldAmount.toLong())
        return buffer.readByteArray()
      }
    }

    public data class MintCloseAuthority(
      public val closeAuthority: PublicKey,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(3)
        buffer.write(closeAuthority.bytes)
        return buffer.readByteArray()
      }
    }

    public data class ConfidentialTransferMint(
      public val authority: PublicKey?,
      public val autoApproveNewAccounts: Boolean,
      public val auditorElgamalPubkey: PublicKey?,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(4)
        if (authority != null) { buffer.write(authority.bytes) } else { buffer.write(ByteArray(32))
            }
        buffer.writeByte(if (autoApproveNewAccounts) 1 else 0)
        if (auditorElgamalPubkey != null) { buffer.write(auditorElgamalPubkey.bytes) } else {
            buffer.write(ByteArray(32)) }
        return buffer.readByteArray()
      }
    }

    public data class ConfidentialTransferAccount(
      public val approved: Boolean,
      public val elgamalPubkey: PublicKey,
      public val pendingBalanceLow: EncryptedBalance,
      public val pendingBalanceHigh: EncryptedBalance,
      public val availableBalance: EncryptedBalance,
      public val decryptableAvailableBalance: DecryptableBalance,
      public val allowConfidentialCredits: Boolean,
      public val allowNonConfidentialCredits: Boolean,
      public val pendingBalanceCreditCounter: ULong,
      public val maximumPendingBalanceCreditCounter: ULong,
      public val expectedPendingBalanceCreditCounter: ULong,
      public val actualPendingBalanceCreditCounter: ULong,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(5)
        buffer.writeByte(if (approved) 1 else 0)
        buffer.write(elgamalPubkey.bytes)
        buffer.write(pendingBalanceLow.bytes)
        buffer.write(pendingBalanceHigh.bytes)
        buffer.write(availableBalance.bytes)
        buffer.write(decryptableAvailableBalance.bytes)
        buffer.writeByte(if (allowConfidentialCredits) 1 else 0)
        buffer.writeByte(if (allowNonConfidentialCredits) 1 else 0)
        buffer.writeLongLe(pendingBalanceCreditCounter.toLong())
        buffer.writeLongLe(maximumPendingBalanceCreditCounter.toLong())
        buffer.writeLongLe(expectedPendingBalanceCreditCounter.toLong())
        buffer.writeLongLe(actualPendingBalanceCreditCounter.toLong())
        return buffer.readByteArray()
      }
    }

    public data class DefaultAccountState(
      public val state: AccountState,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(6)
        buffer.writeByte(state.value.toInt())
        return buffer.readByteArray()
      }
    }

    public object ImmutableOwner : Extension() {
      public override fun serialize(): ByteArray = byteArrayOf(7.toByte())
    }

    public data class MemoTransfer(
      public val requireIncomingTransferMemos: Boolean,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(8)
        buffer.writeByte(if (requireIncomingTransferMemos) 1 else 0)
        return buffer.readByteArray()
      }
    }

    public object NonTransferable : Extension() {
      public override fun serialize(): ByteArray = byteArrayOf(9.toByte())
    }

    public data class InterestBearingConfig(
      public val rateAuthority: PublicKey,
      public val initializationTimestamp: ULong,
      public val preUpdateAverageRate: Short,
      public val lastUpdateTimestamp: ULong,
      public val currentRate: Short,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(10)
        buffer.write(rateAuthority.bytes)
        buffer.writeLongLe(initializationTimestamp.toLong())
        buffer.writeShortLe(preUpdateAverageRate.toInt())
        buffer.writeLongLe(lastUpdateTimestamp.toLong())
        buffer.writeShortLe(currentRate.toInt())
        return buffer.readByteArray()
      }
    }

    public data class CpiGuard(
      public val lockCpi: Boolean,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(11)
        buffer.writeByte(if (lockCpi) 1 else 0)
        return buffer.readByteArray()
      }
    }

    public data class PermanentDelegate(
      public val `delegate`: PublicKey,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(12)
        buffer.write(delegate.bytes)
        return buffer.readByteArray()
      }
    }

    public object NonTransferableAccount : Extension() {
      public override fun serialize(): ByteArray = byteArrayOf(13.toByte())
    }

    public data class TransferHook(
      public val authority: PublicKey,
      public val programId: PublicKey,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(14)
        buffer.write(authority.bytes)
        buffer.write(programId.bytes)
        return buffer.readByteArray()
      }
    }

    public data class TransferHookAccount(
      public val transferring: Boolean,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(15)
        buffer.writeByte(if (transferring) 1 else 0)
        return buffer.readByteArray()
      }
    }

    public data class ConfidentialTransferFee(
      public val authority: PublicKey?,
      public val elgamalPubkey: PublicKey,
      public val harvestToMintEnabled: Boolean,
      public val withheldAmount: EncryptedBalance,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(16)
        if (authority != null) { buffer.write(authority.bytes) } else { buffer.write(ByteArray(32))
            }
        buffer.write(elgamalPubkey.bytes)
        buffer.writeByte(if (harvestToMintEnabled) 1 else 0)
        buffer.write(withheldAmount.bytes)
        return buffer.readByteArray()
      }
    }

    public data class ConfidentialTransferFeeAmount(
      public val withheldAmount: EncryptedBalance,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(17)
        buffer.write(withheldAmount.bytes)
        return buffer.readByteArray()
      }
    }

    public data class MetadataPointer(
      public val authority: PublicKey?,
      public val metadataAddress: PublicKey?,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(18)
        if (authority != null) { buffer.write(authority.bytes) } else { buffer.write(ByteArray(32))
            }
        if (metadataAddress != null) { buffer.write(metadataAddress.bytes) } else {
            buffer.write(ByteArray(32)) }
        return buffer.readByteArray()
      }
    }

    public data class TokenMetadata(
      public val updateAuthority: PublicKey?,
      public val mint: PublicKey,
      public val name: String,
      public val symbol: String,
      public val uri: String,
      public val additionalMetadata: Map<String, String>,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(19)
        if (updateAuthority != null) { buffer.write(updateAuthority.bytes) } else {
            buffer.write(ByteArray(32)) }
        buffer.write(mint.bytes)
        val nameBytes = name.encodeToByteArray()
        buffer.writeIntLe(nameBytes.size)
        buffer.write(nameBytes)
        val symbolBytes = symbol.encodeToByteArray()
        buffer.writeIntLe(symbolBytes.size)
        buffer.write(symbolBytes)
        val uriBytes = uri.encodeToByteArray()
        buffer.writeIntLe(uriBytes.size)
        buffer.write(uriBytes)
        return buffer.readByteArray()
      }
    }

    public data class GroupPointer(
      public val authority: PublicKey?,
      public val groupAddress: PublicKey?,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(20)
        if (authority != null) { buffer.write(authority.bytes) } else { buffer.write(ByteArray(32))
            }
        if (groupAddress != null) { buffer.write(groupAddress.bytes) } else {
            buffer.write(ByteArray(32)) }
        return buffer.readByteArray()
      }
    }

    public data class TokenGroup(
      public val updateAuthority: PublicKey?,
      public val mint: PublicKey,
      public val size: ULong,
      public val maxSize: ULong,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(21)
        if (updateAuthority != null) { buffer.write(updateAuthority.bytes) } else {
            buffer.write(ByteArray(32)) }
        buffer.write(mint.bytes)
        buffer.writeLongLe(size.toLong())
        buffer.writeLongLe(maxSize.toLong())
        return buffer.readByteArray()
      }
    }

    public data class GroupMemberPointer(
      public val authority: PublicKey?,
      public val memberAddress: PublicKey?,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(22)
        if (authority != null) { buffer.write(authority.bytes) } else { buffer.write(ByteArray(32))
            }
        if (memberAddress != null) { buffer.write(memberAddress.bytes) } else {
            buffer.write(ByteArray(32)) }
        return buffer.readByteArray()
      }
    }

    public data class TokenGroupMember(
      public val mint: PublicKey,
      public val group: PublicKey,
      public val memberNumber: ULong,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(23)
        buffer.write(mint.bytes)
        buffer.write(group.bytes)
        buffer.writeLongLe(memberNumber.toLong())
        return buffer.readByteArray()
      }
    }

    public object ConfidentialMintBurn : Extension() {
      public override fun serialize(): ByteArray = byteArrayOf(24.toByte())
    }

    public data class ScaledUiAmountConfig(
      public val authority: PublicKey,
      public val multiplier: Double,
      public val newMultiplierEffectiveTimestamp: ULong,
      public val newMultiplier: Double,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(25)
        buffer.write(authority.bytes)
        buffer.writeLongLe(multiplier.toRawBits())
        buffer.writeLongLe(newMultiplierEffectiveTimestamp.toLong())
        buffer.writeLongLe(newMultiplier.toRawBits())
        return buffer.readByteArray()
      }
    }

    public data class PausableConfig(
      public val authority: PublicKey?,
      public val paused: Boolean,
    ) : Extension() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(26)
        if (authority != null) { buffer.write(authority.bytes) } else { buffer.write(ByteArray(32))
            }
        buffer.writeByte(if (paused) 1 else 0)
        return buffer.readByteArray()
      }
    }

    public object PausableAccount : Extension() {
      public override fun serialize(): ByteArray = byteArrayOf(27.toByte())
    }
  }

  public enum class ExtensionType(
    public val `value`: UShort,
  ) {
    Uninitialized(0u),
    TransferFeeConfig(1u),
    TransferFeeAmount(2u),
    MintCloseAuthority(3u),
    ConfidentialTransferMint(4u),
    ConfidentialTransferAccount(5u),
    DefaultAccountState(6u),
    ImmutableOwner(7u),
    MemoTransfer(8u),
    NonTransferable(9u),
    InterestBearingConfig(10u),
    CpiGuard(11u),
    PermanentDelegate(12u),
    NonTransferableAccount(13u),
    TransferHook(14u),
    TransferHookAccount(15u),
    ConfidentialTransferFee(16u),
    ConfidentialTransferFeeAmount(17u),
    ScaledUiAmountConfig(18u),
    PausableConfig(19u),
    PausableAccount(20u),
    MetadataPointer(21u),
    TokenMetadata(22u),
    GroupPointer(23u),
    TokenGroup(24u),
    GroupMemberPointer(25u),
    TokenGroupMember(26u),
    ;
  }

  public sealed class TokenMetadataField {
    public abstract fun serialize(): ByteArray

    public object Name : TokenMetadataField() {
      public override fun serialize(): ByteArray = byteArrayOf(0.toByte())
    }

    public object Symbol : TokenMetadataField() {
      public override fun serialize(): ByteArray = byteArrayOf(1.toByte())
    }

    public object Uri : TokenMetadataField() {
      public override fun serialize(): ByteArray = byteArrayOf(2.toByte())
    }

    public data class Key(
      public val value0: String,
    ) : TokenMetadataField() {
      public override fun serialize(): ByteArray {
        val buffer = Buffer()
        buffer.writeByte(3)
        val value0Bytes = value0.encodeToByteArray()
        buffer.writeIntLe(value0Bytes.size)
        buffer.write(value0Bytes)
        return buffer.readByteArray()
      }
    }
  }

  public enum class Instruction(
    public val index: UByte,
  ) {
    InitializeMint(0u),
    InitializeAccount(1u),
    InitializeMultisig(2u),
    Transfer(3u),
    Approve(4u),
    Revoke(5u),
    SetAuthority(6u),
    MintTo(7u),
    Burn(8u),
    CloseAccount(9u),
    FreezeAccount(10u),
    ThawAccount(11u),
    TransferChecked(12u),
    ApproveChecked(13u),
    MintToChecked(14u),
    BurnChecked(15u),
    InitializeAccount2(16u),
    SyncNative(17u),
    InitializeAccount3(18u),
    InitializeMultisig2(19u),
    InitializeMint2(20u),
    GetAccountDataSize(21u),
    InitializeImmutableOwner(22u),
    AmountToUiAmount(23u),
    UiAmountToAmount(24u),
    InitializeMintCloseAuthority(25u),
    InitializeTransferFeeConfig(26u),
    TransferCheckedWithFee(26u),
    WithdrawWithheldTokensFromMint(26u),
    WithdrawWithheldTokensFromAccounts(26u),
    HarvestWithheldTokensToMint(26u),
    SetTransferFee(26u),
    InitializeConfidentialTransferMint(27u),
    UpdateConfidentialTransferMint(27u),
    ConfigureConfidentialTransferAccount(27u),
    ApproveConfidentialTransferAccount(27u),
    EmptyConfidentialTransferAccount(27u),
    ConfidentialDeposit(27u),
    ConfidentialWithdraw(27u),
    ConfidentialTransfer(27u),
    ApplyConfidentialPendingBalance(27u),
    EnableConfidentialCredits(27u),
    DisableConfidentialCredits(27u),
    EnableNonConfidentialCredits(27u),
    DisableNonConfidentialCredits(27u),
    ConfidentialTransferWithFee(27u),
    InitializeDefaultAccountState(28u),
    UpdateDefaultAccountState(28u),
    Reallocate(29u),
    EnableMemoTransfers(30u),
    DisableMemoTransfers(30u),
    CreateNativeMint(31u),
    InitializeNonTransferableMint(32u),
    InitializeInterestBearingMint(33u),
    UpdateRateInterestBearingMint(33u),
    EnableCpiGuard(34u),
    DisableCpiGuard(34u),
    InitializePermanentDelegate(35u),
    InitializeTransferHook(36u),
    UpdateTransferHook(36u),
    InitializeConfidentialTransferFee(37u),
    WithdrawWithheldTokensFromMintForConfidentialTransferFee(37u),
    WithdrawWithheldTokensFromAccountsForConfidentialTransferFee(37u),
    HarvestWithheldTokensToMintForConfidentialTransferFee(37u),
    EnableHarvestToMint(37u),
    DisableHarvestToMint(37u),
    WithdrawExcessLamports(38u),
    InitializeMetadataPointer(39u),
    UpdateMetadataPointer(39u),
    InitializeGroupPointer(40u),
    UpdateGroupPointer(40u),
    InitializeGroupMemberPointer(41u),
    UpdateGroupMemberPointer(41u),
    InitializeScaledUiAmountMint(43u),
    UpdateMultiplierScaledUiMint(43u),
    InitializePausableConfig(44u),
    Pause(44u),
    Resume(44u),
    UnwrapLamports(45u),
    ;
  }
}
