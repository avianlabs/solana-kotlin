// This code was AUTOGENERATED using Codama IDLs.
// Deprecated backward-compatibility wrappers below the generated code are manually maintained.
// To regenerate: ./gradlew :codegen:generateSolanaCode
//
// IDL source: codegen/idl/token.json

package net.avianlabs.solana.domain.program

import kotlin.Deprecated
import kotlin.UByte
import net.avianlabs.solana.domain.core.AccountMeta
import net.avianlabs.solana.domain.core.TransactionInstruction
import net.avianlabs.solana.domain.program.Program.Companion.createTransactionInstruction
import net.avianlabs.solana.tweetnacl.ed25519.PublicKey
import okio.Buffer

public object AssociatedTokenProgram : Program {
  public override val programId: PublicKey =
      PublicKey.fromBase58("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")

  /**
   * Creates an associated token account for the given wallet address and
   * token mint Returns an error if the account exists.
   */
  public fun createAssociatedToken(
    payer: PublicKey,
    ata: PublicKey,
    owner: PublicKey,
    mint: PublicKey,
    systemProgram: PublicKey = SystemProgram.programId,
    tokenProgram: PublicKey = TokenProgram.programId,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(payer, isSigner = true, isWritable = true),
      AccountMeta(ata, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = false, isWritable = false),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(systemProgram, isSigner = false, isWritable = false),
      AccountMeta(tokenProgram, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.CreateAssociatedToken.index.toInt())
      .readByteArray(),
  )

  @Deprecated(
    message = "Use createAssociatedToken instead",
    replaceWith =
        ReplaceWith("createAssociatedToken(payer = payer, ata = associatedAccount, owner = owner, mint = mint, systemProgram = systemProgram, tokenProgram = programId)"),
    level = DeprecationLevel.ERROR,
  )
  public fun createAssociatedTokenAccountInstruction(
    associatedProgramId: PublicKey = this.programId,
    payer: PublicKey,
    associatedAccount: PublicKey,
    owner: PublicKey,
    mint: PublicKey,
    systemProgram: PublicKey,
    programId: PublicKey,
  ): TransactionInstruction = createAssociatedToken(payer, associatedAccount, owner, mint,
      systemProgram, programId)

  /**
   * Creates an associated token account for the given wallet address and
   * token mint, if it doesn't already exist. Returns an error if the
   * account exists, but with a different owner.
   */
  public fun createAssociatedTokenIdempotent(
    payer: PublicKey,
    ata: PublicKey,
    owner: PublicKey,
    mint: PublicKey,
    systemProgram: PublicKey = SystemProgram.programId,
    tokenProgram: PublicKey = TokenProgram.programId,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(payer, isSigner = true, isWritable = true),
      AccountMeta(ata, isSigner = false, isWritable = true),
      AccountMeta(owner, isSigner = false, isWritable = false),
      AccountMeta(mint, isSigner = false, isWritable = false),
      AccountMeta(systemProgram, isSigner = false, isWritable = false),
      AccountMeta(tokenProgram, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.CreateAssociatedTokenIdempotent.index.toInt())
      .readByteArray(),
  )

  @Deprecated(
    message = "Use createAssociatedTokenIdempotent instead",
    replaceWith =
        ReplaceWith("createAssociatedTokenIdempotent(payer = payer, ata = associatedAccount, owner = owner, mint = mint, systemProgram = systemProgram, tokenProgram = programId)"),
    level = DeprecationLevel.ERROR,
  )
  public fun createAssociatedTokenAccountInstructionIdempotent(
    associatedProgramId: PublicKey = this.programId,
    payer: PublicKey,
    associatedAccount: PublicKey,
    owner: PublicKey,
    mint: PublicKey,
    systemProgram: PublicKey,
    programId: PublicKey,
  ): TransactionInstruction = createAssociatedTokenIdempotent(payer, associatedAccount, owner, mint,
      systemProgram, programId)

  /**
   * Transfers from and closes a nested associated token account: an
   * associated token account owned by an associated token account.
   *
   * The tokens are moved from the nested associated token account to the
   * wallet's associated token account, and the nested account lamports are
   * moved to the wallet.
   *
   * Note: Nested token accounts are an anti-pattern, and almost always
   * created unintentionally, so this instruction should only be used to
   * recover from errors.
   */
  public fun recoverNestedAssociatedToken(
    nestedAssociatedAccountAddress: PublicKey,
    nestedTokenMintAddress: PublicKey,
    destinationAssociatedAccountAddress: PublicKey,
    ownerAssociatedAccountAddress: PublicKey,
    ownerTokenMintAddress: PublicKey,
    walletAddress: PublicKey,
    tokenProgram: PublicKey = TokenProgram.programId,
  ): TransactionInstruction = createTransactionInstruction(
    programId = programId,
    keys = listOf(
      AccountMeta(nestedAssociatedAccountAddress, isSigner = false, isWritable = true),
      AccountMeta(nestedTokenMintAddress, isSigner = false, isWritable = false),
      AccountMeta(destinationAssociatedAccountAddress, isSigner = false, isWritable = true),
      AccountMeta(ownerAssociatedAccountAddress, isSigner = false, isWritable = false),
      AccountMeta(ownerTokenMintAddress, isSigner = false, isWritable = false),
      AccountMeta(walletAddress, isSigner = true, isWritable = true),
      AccountMeta(tokenProgram, isSigner = false, isWritable = false),
    ),
    data = Buffer()
      .writeByte(Instruction.RecoverNestedAssociatedToken.index.toInt())
      .readByteArray(),
  )

  public enum class Instruction(
    public val index: UByte,
  ) {
    CreateAssociatedToken(0u),
    CreateAssociatedTokenIdempotent(1u),
    RecoverNestedAssociatedToken(2u),
    ;
  }
}
